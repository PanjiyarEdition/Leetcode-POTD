# 📍Description ➡:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
Each basket can hold only one type of fruit.
If a fruit type cannot be placed in any basket, it remains unplaced.
Return the number of fruit types that remain unplaced after all possible allocations are made.

 

# 📝Code ⬇:-


# Java
```java []
class Solution {
    int n;
    int[] seg;
    void Update(int p) { 
        seg[p] = Math.max(seg[p << 1], seg[p << 1 | 1]); 
    }
    void Build(int p, int l, int r, int[] baskets) {
        if (l == r) {
            seg[p] = baskets[l];
            return;
        }
        int mid = (l + r) >> 1;
        Build(p << 1, l, mid, baskets);
        Build(p << 1 | 1, mid + 1, r, baskets);
        Update(p);
    }
    void Assign(int x, int v, int p, int l, int r) {
        if (x < l || x > r) {
            return;
        }
        if (l == r) {
            seg[p] = v;
            return;
        }
        int mid = (l + r) >> 1;
        Assign(x, v, p << 1, l, mid);
        Assign(x, v, p << 1 | 1, mid + 1, r);
        Update(p);
    }
    int FirstLarger(int v, int p, int l, int r) {
        if (seg[p] < v) {
            return r + 1;
        }
        if (l == r) {
            return r;
        }
        int mid = (l + r) >> 1;
        int lf = FirstLarger(v, p << 1, l, mid);
        if (lf <= mid) {
            return lf;
        }
        return FirstLarger(v, p << 1 | 1, mid + 1, r);
    }
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        n = fruits.length;
        seg = new int[4 * n + 1];
        Build(1, 0, n - 1, baskets);
        int res = 0;
        for (int x : fruits) {
            int pos = FirstLarger(x, 1, 0, n - 1);
            if (pos == n) {
                res++;
            } else {
                Assign(pos, 0, 1, 0, n - 1);
            }
        }
        return res;
    }
}

```

# C++
``` cpp []
class Solution {
    int n;
    vector<int> seg;
    void Update(int p) { 
        seg[p] = max(seg[p << 1], seg[p << 1 | 1]); 
    }

    void Build(int p, int l, int r, vector<int>& baskets) {
        if (l == r) {
            seg[p] = baskets[l];
            return;
        }
        int mid = (l + r) >> 1;
        Build(p << 1, l, mid, baskets);
        Build(p << 1 | 1, mid + 1, r, baskets);
        Update(p);
    }
    void Assign(int x, int v, int p, int l, int r) {
        if (x < l || x > r) {
            return;
        }
        if (l == r) {
            seg[p] = v;
            return;
        }
        int mid = (l + r) >> 1;
        Assign(x, v, p << 1, l, mid);
        Assign(x, v, p << 1 | 1, mid + 1, r);
        Update(p);
    }
    int FirstLarger(int v, int p, int l, int r) {
        if (seg[p] < v) {
            return r + 1;
        }
        if (l == r) {
            return r;
        }
        int mid = (l + r) >> 1;
        int lf = FirstLarger(v, p << 1, l, mid);
        if (lf <= mid) {
            return lf;
        }
        return FirstLarger(v, p << 1 | 1, mid + 1, r);
    }

public:
    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        n = fruits.size();
        seg.assign(4 * n + 1, 0);
        Build(1, 0, n - 1, baskets);
        int res = 0;
        for (const auto& x : fruits) {
            int pos = FirstLarger(x, 1, 0, n - 1);
            if (pos == n) {
                res++;
            } else {
                Assign(pos, 0, 1, 0, n - 1);
            }
        }
        return res;
    }
};
```

# Python
``` python []
class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        n = len(fruits)
        seg = [0] * (4 * n + 1)
        def Update(p):
            seg[p] = max(seg[p << 1], seg[p << 1 | 1])
        def Build(p, l, r):
            if l == r:
                seg[p] = baskets[l]
                return
            mid = (l + r) >> 1
            Build(p << 1, l, mid)
            Build(p << 1 | 1, mid + 1, r)
            Update(p)
        def Assign(x, v, p, l, r):
            if x < l or x > r:
                return
            if l == r:
                seg[p] = v
                return
            mid = (l + r) >> 1
            Assign(x, v, p << 1, l, mid)
            Assign(x, v, p << 1 | 1, mid + 1, r)
            Update(p)
        def FirstLarger(v, p, l, r):
            if seg[p] < v:
                return r + 1
            if l == r:
                return r
            mid = (l + r) >> 1
            lf = FirstLarger(v, p << 1, l, mid)
            if lf <= mid:
                return lf
            return FirstLarger(v, p << 1 | 1, mid + 1, r)
        Build(1, 0, n - 1)
        res = 0
        for x in fruits:
            pos = FirstLarger(x, 1, 0, n - 1)
            if pos == n:
                res += 1
            else:
                Assign(pos, 0, 1, 0, n - 1)
        return res
```

---

>    **Coded** By $$Panjiyar EDITION 🖋  $$

               
