# ??Description ?:-

<!-- Describe your first thoughts on how to solve this problem. -->
You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR.

In other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.
The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.

A subarray is a contiguous non-empty sequence of elements within an array.

# ??Code ?:-

```java []

class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int len = nums.length;
        int[] lastSeen = new int[30];
        int[] res = new int[len];
        for (int i = 0; i < len; i++) res[i] = 1;
        for (int i = len - 1; i >= 0; i--) {
            for (int bit = 0; bit < 30; bit++) {
                if ((nums[i] & (1 << bit)) > 0) lastSeen[bit] = i;
                res[i] = Math.max(res[i], lastSeen[bit] - i + 1);
            }
        }
        return res;
    }
}

```

# C++

``` cpp []

class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> lastSeen(30, 0), res(n, 1);
        for (int i = n - 1; i >= 0; --i) {
            for (int bit = 0; bit < 30; ++bit) {
                if ((nums[i] & (1 << bit)) > 0)
                    lastSeen[bit] = i;
                res[i] = max(res[i], lastSeen[bit] - i + 1);
            }
        }
        return res;
    }
};

```

# Python

``` python []

class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        last_seen = [0] * 30
        res = [1] * n
        for i in range(n - 1, -1, -1):
            for bit in range(30):
                if (nums[i] & (1 << bit)) > 0:
                    last_seen[bit] = i
                res[i] = max(res[i], last_seen[bit] - i + 1)
        return res

```

---

>    **Coded** By $$Panjiyar EDITION ??  $$
