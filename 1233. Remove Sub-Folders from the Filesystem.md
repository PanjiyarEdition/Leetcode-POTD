# 📍Description ➡:-
<!-- Describe your first thoughts on how to solve this problem. -->
Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.

If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a "/". For example, "/a/b" is a sub-folder of "/a", but "/b" is not a sub-folder of "/a/b/c".

The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.

For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.


# 📝Code ⬇:-


# Java
```java []
import java.util.*;

class Solution {
    public List<String> removeSubfolders(String[] folder) {
        Arrays.sort(folder);
        List<String> ans = new ArrayList<>();
        ans.add(folder[0]);

        for (int i = 1; i < folder.length; i++) {
            if (!folder[i].startsWith(ans.get(ans.size() - 1) + "/")) {
                ans.add(folder[i]);
            }
        }
        return ans;
    }
}

```

# C++
``` cpp []
class Solution {
public:
     vector<string> removeSubfolders(vector<string>& folder) {
        sort(folder.begin(), folder.end());
        vector<string> ans;
        ans.push_back(folder[0]);
        for(int i=1; i<folder.size(); i++) {
            string lastFolder = ans[ans.size() - 1] + "/";
            if(!folder[i].starts_with(lastFolder))
                ans.push_back(folder[i]);
        }
        return ans;   
    }
};
```

# Python
``` python []
class Solution:
    def removeSubfolders(self, folder):
        folder.sort()
        ans = [folder[0]]
        
        for f in folder[1:]:
            if not f.startswith(ans[-1] + "/"):
                ans.append(f)
                
        return ans   
```

---

>    **Coded** By $$Panjiyar EDITION 🖋  $$

               
