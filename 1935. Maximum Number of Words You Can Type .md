# ğŸ“Description â¡:-
<!-- Describe your first thoughts on how to solve this problem. -->
There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.


# ğŸ“Code â¬‡:-


# Java
```java []

class Solution {
    public int canBeTypedWords(String text, String broken) {
        int mask = 0;
        for (int i = 0; i < broken.length(); i++) {
            mask |= 1 << (broken.charAt(i) - 97);
        }

        int count = 0;
        boolean brokenWord = false;
        for (int i = 0; i <= text.length(); i++) {
            if (i < text.length() && (mask & (1 << (text.charAt(i) - 97))) != 0) brokenWord = true;
            if (i == text.length() || text.charAt(i) == ' ') {
                if (!brokenWord) count++;
                brokenWord = false;
            }
        }
        return count;
    }
}

```

# C++
``` cpp []
class Solution {
public:
    int canBeTypedWords(string text, string broken) {
        int mask = 0;
        for (int i = 0; i < broken.size(); i++) {
            mask |= 1 << (broken[i] - 97);
        }

        int count = 0;
        bool brokenWord = false;
        for (int i = 0; i <= text.size(); i++) {
            if (i < text.size() && text[i] >= 'a' && text[i] <= 'z' &&
                (mask & (1 << (text[i] - 97))) != 0)
            {
                brokenWord = true;
            }
            if (i == text.size() || text[i] == ' ') {
                if (!brokenWord) count++;
                brokenWord = false;
            }
        }
        return count;
    }
};
```

# Python
``` python []

class Solution:
    def canBeTypedWords(self, text: str, broken: str) -> int:
        mask = 0
        for ch in broken:
            mask |= 1 << (ord(ch) - 97)
        
        count = 0
        brokenWord = False
        n = len(text)
        for i in range(n + 1):
            if i < n and 'a' <= text[i] <= 'z' and (mask & (1 << (ord(text[i]) - 97))):
                brokenWord = True
            if i == n or text[i] == ' ':
                if not brokenWord:
                    count += 1
                brokenWord = False
        return count     
```

---

>    **Coded** By $$Panjiyar EDITION ğŸ–‹  $$

               
