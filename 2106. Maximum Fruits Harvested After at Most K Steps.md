# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.

You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.


# üìùCode ‚¨á:-


# Java
```java []
class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int n = fruits.length;
        if (n == 0) {
            return 0;
        }

        int[] positions = new int[n];
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            positions[i] = fruits[i][0];
            prefixSum[i + 1] = prefixSum[i] + fruits[i][1];
        }

        long maxFruits = 0;
        int left = 0;
        for (int right = 0; right < n; right++) {
            long posL = positions[left];
            long posR = positions[right];

            // Calculate the minimum steps to cover the current window [posL, posR]
            long cost = (posR - posL) + Math.min(Math.abs(startPos - posL), Math.abs(startPos - posR));

            // If the cost is too high, shrink the window from the left
            while (left <= right && cost > k) {
                left++;
                if (left > right) break;
                posL = positions[left];
                cost = (posR - posL) + Math.min(Math.abs(startPos - posL), Math.abs(startPos - posR));
            }

            // If the window is valid, calculate fruits and update max
            if (left <= right) {
                long currentFruits = prefixSum[right + 1] - prefixSum[left];
                maxFruits = Math.max(maxFruits, currentFruits);
            }
        }

        return (int) maxFruits;
    }
}

```

# C++
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n = fruits.size();
        if (n == 0) {
            return 0;
        }

        vector<int> positions(n);
        vector<long long> prefix_sum(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            positions[i] = fruits[i][0];
            prefix_sum[i + 1] = prefix_sum[i] + fruits[i][1];
        }

        long long max_fruits = 0;
        int left = 0;
        for (int right = 0; right < n; ++right) {
            long long pos_l = positions[left];
            long long pos_r = positions[right];

            // Calculate the minimum steps to cover the current window [pos_l, pos_r]
            long long cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r));

            // If the cost is too high, shrink the window from the left
            while (left <= right && cost > k) {
                left++;
                if (left > right) break;
                pos_l = positions[left];
                cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r));
            }

            // If the window is valid, calculate fruits and update max
            if (left <= right) {
                long long current_fruits = prefix_sum[right + 1] - prefix_sum[left];
                max_fruits = max(max_fruits, current_fruits);
            }
        }

        return static_cast<int>(max_fruits);
    }
};
```

# Python
``` python []
import math

class Solution:
    def maxTotalFruits(self, fruits: list[list[int]], startPos: int, k: int) -> int:
        n = len(fruits)
        
        # Positions and prefix sums for quick calculations
        positions = [fruit[0] for fruit in fruits]
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i+1] = prefix_sum[i] + fruits[i][1]

        max_fruits = 0
        left = 0
        for right in range(n):
            # Current window of fruits is from index `left` to `right`
            pos_l, pos_r = positions[left], positions[right]
            
            # Calculate the minimum steps to cover the current window [pos_l, pos_r]
            # This is the cost to travel the segment plus the cost to get to the nearer end
            cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r))

            # If the cost is too high, shrink the window from the left
            while left <= right and cost > k:
                left += 1
                if left > right:
                    break
                # Recalculate cost for the new, smaller window
                pos_l, pos_r = positions[left], positions[right]
                cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r))

            # If the window is valid, calculate fruits and update max
            if left <= right:
                current_fruits = prefix_sum[right + 1] - prefix_sum[left]
                max_fruits = max(max_fruits, current_fruits)
                
        return max_fruits     
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
