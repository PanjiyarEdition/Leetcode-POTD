# ğŸ“Description â¡:-
<!-- Describe your first thoughts on how to solve this problem. -->
Given an m x n binary matrix mat, return the number of submatrices that have all ones.

 

 


# ğŸ“Code â¬‡:-


# Java
```java []
class Solution {
    public int numSubmat(int[][] mat) {
        int r = mat.length, c = mat[0].length;
        int[] h = new int[c];
        int ans = 0;

        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                h[j] = (mat[i][j] == 0) ? 0 : h[j] + 1;
            }
            ans += count(h);
        }
        return ans;
    }

    private int count(int[] h) {
        int n = h.length, res = 0;
        int[] sum = new int[n];
        Deque<Integer> st = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            while (!st.isEmpty() && h[st.peek()] >= h[i]) st.pop();
            if (!st.isEmpty()) {
                int p = st.peek();
                sum[i] = sum[p] + h[i] * (i - p);
            } else {
                sum[i] = h[i] * (i + 1);
            }
            st.push(i);
            res += sum[i];
        }
        return res;
    }
}

```

# C++
``` cpp []
class Solution {
public:
    int numSubmat(vector<vector<int>>& mat) {
        int r = mat.size(), c = mat[0].size(), ans = 0;
        vector<int> h(c);
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) h[j] = mat[i][j] ? h[j] + 1 : 0;
            vector<int> sum(c);
            stack<int> st;
            for (int j = 0; j < c; j++) {
                while (!st.empty() && h[st.top()] >= h[j]) st.pop();
                if (!st.empty()) {
                    int p = st.top();
                    sum[j] = sum[p] + h[j] * (j - p);
                } else {
                    sum[j] = h[j] * (j + 1);
                }
                st.push(j);
                ans += sum[j];
            }
        }
        return ans;
    }
};
```

# Python
``` python []
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        r, c = len(mat), len(mat[0])
        h = [0] * c
        ans = 0
        for i in range(r):
            for j in range(c):
                h[j] = h[j] + 1 if mat[i][j] else 0
            sumv, st = [0] * c, []
            for j in range(c):
                while st and h[st[-1]] >= h[j]:
                    st.pop()
                if st:
                    p = st[-1]
                    sumv[j] = sumv[p] + h[j] * (j - p)
                else:
                    sumv[j] = h[j] * (j + 1)
                st.append(j)
                ans += sumv[j]
        return ans   
```

---

>    **Coded** By $$Panjiyar EDITION ğŸ–‹  $$

               
