# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair.

Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b].

Return the maximum number of subarrays possible after removing exactly one conflicting pair.

# üìùCode ‚¨á:-


# Java
```java []
import java.util.ArrayList;
import java.util.List;

class Solution {
    public long maxSubarrays(int n, int[][] conflictingPairs) {
        List<Integer>[] right = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            right[i] = new ArrayList<>();
        }
        for (int[] pair : conflictingPairs) {
            right[Math.max(pair[0], pair[1])].add(Math.min(pair[0], pair[1]));
        }

        long ans = 0;
        long[] left = {0, 0}; // left[0] is top1, left[1] is top2
        long[] bonus = new long[n + 1];

        for (int r = 1; r <= n; r++) {
            for (int l_val : right[r]) {
                // Manually update top two values
                if (l_val > left[0]) {
                    left[1] = left[0];
                    left[0] = l_val;
                } else if (l_val > left[1]) {
                    left[1] = l_val;
                }
            }

            ans += r - left[0];
            
            if (left[0] > 0) {
                bonus[(int)left[0]] += left[0] - left[1];
            }
        }
        
        long maxBonus = 0;
        for (long b : bonus) {
            maxBonus = Math.max(maxBonus, b);
        }

        return ans + maxBonus;
    }
}
```

# C++
``` cpp []
typedef long long ll;
class Solution {
public:
    long long maxSubarrays(int n, vector<vector<int>>& conflictingPairs) {
        int m = conflictingPairs.size();
        // Swap to get correct left / right endpoint
        for(int i = 0; i < m; i++) {
            if (conflictingPairs[i][0] > conflictingPairs[i][1])
                swap(conflictingPairs[i][0], conflictingPairs[i][1]);
        }
        // Sort with right endpoint, then left endpoint
        sort(conflictingPairs.begin(), conflictingPairs.end(), [](auto& x, auto& y) {
            return x[1] != y[1] ? x[1] < y[1] : x[0] < y[0];
        });
        int j = 0;
        // Subarrays with left end in [mxlb, curlb] (both inclusive) can contribute to pair `cur`
        int mxlb = 1, curlb = 1, cur = -1;
        vector<ll> res(m, 0);
        ll ans = 0;
        for(int i = 1; i <= n; i++) {
            // At each step, we need to process all pairs that has appeared
            // Sorting with left endpoint also guarantees correctness during the processing
            while(j < m && conflictingPairs[j][1] <= i) {
                if (cur == -1) {
                    // No contribution now
                    // However, if left end is to the left of mxlb
                    // it will cover another pair, so can't contribute to it
                    if (mxlb <= conflictingPairs[j][0]) {
                        curlb = conflictingPairs[j][0];
                        cur = j;
                    }
                } else if (conflictingPairs[j][0] < curlb) {
                    // No challenge to current pair
                    mxlb = max(mxlb, conflictingPairs[j][0] + 1);
                } else if (conflictingPairs[j][0] == curlb) {
                    // Same left endpoint, can't contribute
                    mxlb = curlb + 1;
                    cur = -1;
                } else {
                    // Refresh contribution to pair j
                    mxlb = curlb + 1;
                    curlb = conflictingPairs[j][0];
                    cur = j;
                }
                j++;
            }
            if (cur != -1) {
                // Do the contribution!
                res[cur] += curlb - mxlb + 1;
            }
            // Calculate base problem result, squeezed into the same iteration
            if (cur == -1) ans += i - mxlb + 1;
            else ans += i - curlb;
        }
        ll resmx = 0;
        for(int i = 0; i < m; i++) {
            resmx = max(resmx, res[i]);
        }
        return ans + resmx;
    }
};
```

# Python
``` python []
from typing import List

class Solution:
    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:
        
        # Group all `u` values by their `v` endpoint
        right = [[] for _ in range(n + 1)]
        for a, b in conflictingPairs:
            right[max(a, b)].append(min(a, b))
        
        # Base score
        ans = 0 
        # `left` stores [top1, top2] `u` values seen so far, where top1 >= top2.
        # `left[0]` acts as our running `forbidden_start`.
        left = [0, 0] 
        # `bonus[u]` accumulates the total gain if the critical conflict involving `u` is removed.
        bonus = [0] * (n + 1)
        
        # Single pass from r = 1 to n
        for r in range(1, n + 1):
            # Check for new conflicts ending at `r` and update `left`
            for l in right[r]:
                # This is a concise trick to update the top two seen values
                if l > left[0]:
                    left = [l, left[0]]
                elif l > left[1]:
                    left = [left[0], l]
            
            # Add the count for this endpoint to the base score
            ans += r - left[0]

            # The gain at this step is the difference between the top two forbidden starts.
            # We add this gain to the tally for the `u` value causing the restriction (`left[0]`).
            if left[0] > 0:
                bonus[left[0]] += left[0] - left[1]
        
        # The final result is the base score plus the maximum possible gain.
        return ans + max(bonus)
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
