# 📍Description ➡:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given an integer array nums.

You are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that:

All elements in the subarray are unique.
The sum of the elements in the subarray is maximized.
Return the maximum sum of such a subarray.


# 📝Code ⬇:-


# Java
```java []
import java.util.*;

class Solution {
    public int maxSum(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) set.add(num);

        int result = 0;
        for (int num : set) {
            if (num > 0) result += num;
        }

        if (result == 0) {
            result = Collections.max(set);
        }

        return result;
    }
}

```

# C++
``` cpp []
class Solution {
public:
    int maxSum(vector<int>& nums) {
        int sum = 0;
        set<int> st;
        int mxNeg = INT_MIN;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0)
                st.insert(nums[i]);
            else
                mxNeg = max(mxNeg, nums[i]);
        }
        for (auto val : st) {
            sum += val;
        }
        if (st.size())
            return sum;
        else
            return mxNeg;
    }
};
```

# Python
``` python []
class Solution:
    def maxSum(self, nums):
        s = set(nums)
        result = sum(x for x in s if x > 0)
        if result == 0:
            result = max(s)
        return result  
```

---

>    **Coded** By $$Panjiyar EDITION 🖋  $$

               
