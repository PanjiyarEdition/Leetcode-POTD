# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.

You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.

Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.


# üìùCode ‚¨á:-


# Java
```java []
class Solution {
    public int[] productQueries(int n, int[][] queries) {
        return ((java.util.function.Function<java.util.List<Integer>, int[]>) a -> {
            int MOD = 1_000_000_007;
            int[] res = new int[queries.length];
            for (int i = 0; i < queries.length; i++) {
                int left = queries[i][0];
                int right = queries[i][1];
                res[i] = (int) (Math.pow(2, a.get(right + 1) - a.get(left)) % MOD);
            }
            return res;
        }).apply(
            new java.util.ArrayList<Integer>() {{
                add(0);
                for (int i = 0; i < 31; i++) {
                    if (((n >> i) & 1) == 1) {
                        add(get(size() - 1) + i);
                    }
                }
            }}
        );
    }
}


```

# C++
``` cpp []
class Solution {
public:
    vector<int> productQueries(int n, vector<vector<int>>& queries) 
    {
        vector<int>power;

        for(int i=0;i<31;i++)
        {
            if((1<<i)&n)
            {
                power.push_back(1<<i);
            }
        }
        int mod=1e9+7;
        int m=power.size();
        vector<vector<int>>dp(m+1,vector<int>(m+1,1));

        for(int i=0;i<m;i++)
        {
            dp[i][i]=power[i];
        }
        for(int i=0;i<m;i++)
        {
            for(int j=i+1;j<m;j++)
            {
                long long res=(dp[i][j-1])*((long long)power[j]);
                dp[i][j]=res%mod;
            }
        }


        vector<int>ans;
        for(auto it:queries)
        {
            long long prd=1;
            int left=it[0];
            int right=it[1];
            
            ans.push_back(dp[left][right]);
        }
        return ans;

        
    }
};
```

# Python
``` python []
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 10**9 + 7
        arr = [1]
        for i in range(31):
            if 1 <<i & n:
                arr.append(1 << i)
        for i in range(1, len(arr)):
            arr[i] *= arr[i - 1]
        ans = []
        for a, b in queries:
            ans.append((arr[b + 1] // arr[a]) % MOD)
        return ans     
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
