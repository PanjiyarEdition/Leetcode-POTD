# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.

A V-shaped diagonal segment is defined as:

The segment starts with 1.
The subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....
The segment:
Starts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).
Continues the sequence in the same diagonal direction.
Makes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.


# üìùCode ‚¨á:-


# Java
```java []
class Solution {
    int dirs[][] = {{-1,1},{1,1},{1,-1},{-1,-1}};
    int [][] grid;
    int row, col;   

    public int lenOfVDiagonal(int[][] grid) {
        row = grid.length;
        col = grid[0].length;
        this.grid = grid;
        int res = 0;
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                if(grid[i][j] == 1) {
                    res = Math.max(res, 1);
                    for(int d = 0; d < 4; d++) {
                        //row , col , direction , target , isTurned
                        res = Math.max(res, dfs(i, j, d, 2,false));
                    }
                }
            }
        }
        return res;
    }

    private int dfs(int i, int j , int dir ,int target, boolean isTurned){
        int x = i + dirs[dir][0];//next position
        int y = j + dirs[dir][1];//next position

        //  x and y in boundarys and that posion is target
        if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != target) return 1;

        int straight = 1 + dfs(x, y, dir, target == 2 ? 0: 2, isTurned);//continue in the same direction

        int turn = 0; //length after turn
        if(!isTurned) { //can turn only once
            // dir + 1 --> 90deg turn
            turn = 1 + dfs(x, y, (dir + 1) % 4, target == 2 ? 0: 2, true);
        }
        return Math.max(straight, turn);
    }
}

```

# C++
``` cpp []
class Solution {
public:
    int lenOfVDiagonal(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        // 4 diagonal directions: ‚Üó, ‚Üò, ‚Üô, ‚Üñ
        vector<pair<int,int>> dirs = {{-1,1},{1,1},{1,-1},{-1,-1}};
        int cw[4] = {1,2,3,0}; // clockwise mapping

        auto inb = [&](int i,int j){ return 0<=i && i<n && 0<=j && j<m; };

        // DP tables
        vector endLen(4, vector(n, vector<int>(m,0)));   // longest valid run ending at (i,j) in dir d
        vector steps(4, vector(n, vector<int>(m,-1)));   // steps since starting '1' (to know next expected value)

        // Order that guarantees predecessor is computed first (for each direction)
        auto iter_order = [&](int d){
            auto [dx,dy] = dirs[d];
            vector<pair<int,int>> cells;
            if (dx>0) {
                for (int i=0;i<n;i++) {
                    if (dy>0) for (int j=0;j<m;j++) cells.push_back({i,j});
                    else      for (int j=m-1;j>=0;j--) cells.push_back({i,j});
                }
            } else {
                for (int i=n-1;i>=0;i--) {
                    if (dy>0) for (int j=0;j<m;j++) cells.push_back({i,j});
                    else      for (int j=m-1;j>=0;j--) cells.push_back({i,j});
                }
            }
            return cells;
        };

        // Build straight (no-turn) runs that start at '1' and follow 1,2,0,2,0...
        for (int d=0; d<4; ++d) {
            auto [dx,dy] = dirs[d];
            for (auto [i,j] : iter_order(d)) {
                int v = grid[i][j];
                if (v==1) { endLen[d][i][j]=1; steps[d][i][j]=0; }
                else {
                    int pi=i-dx, pj=j-dy;
                    if (inb(pi,pj) && endLen[d][pi][pj]>0) {
                        int k = steps[d][pi][pj];
                        int need = ((k+1)&1) ? 2 : 0; // next expected value
                        if (v==need) { endLen[d][i][j]=endLen[d][pi][pj]+1; steps[d][i][j]=k+1; }
                    }
                }
            }
        }

        // Continuation tables after a clockwise turn: alternating runs starting at current cell
        vector from0(4, vector(n, vector<int>(m,0))); // start with 0 then 2,0,2...
        vector from2(4, vector(n, vector<int>(m,0))); // start with 2 then 0,2,0...

        auto iter_reverse = [&](int d){
            auto [dx,dy] = dirs[d];
            vector<pair<int,int>> cells;
            if (dx>0) {
                for (int i=n-1;i>=0;i--) {
                    if (dy>0) for (int j=m-1;j>=0;j--) cells.push_back({i,j});
                    else      for (int j=0;j<m;j++)    cells.push_back({i,j});
                }
            } else {
                for (int i=0;i<n;i++) {
                    if (dy>0) for (int j=m-1;j>=0;j--) cells.push_back({i,j});
                    else      for (int j=0;j<m;j++)    cells.push_back({i,j});
                }
            }
            return cells;
        };

        for (int d=0; d<4; ++d) {
            auto [dx,dy] = dirs[d];
            for (auto [i,j] : iter_reverse(d)) {
                int v = grid[i][j];
                int ni=i+dx, nj=j+dy;
                if (v==0) {
                    int best=1;
                    if (inb(ni,nj) && grid[ni][nj]==2) best = 1 + from2[d][ni][nj];
                    from0[d][i][j]=best;
                } else if (v==2) {
                    int best=1;
                    if (inb(ni,nj) && grid[ni][nj]==0) best = 1 + from0[d][ni][nj];
                    from2[d][i][j]=best;
                }
            }
        }

        int ans = 0;

        // Combine: either no turn, or one clockwise turn then continue
        for (int d=0; d<4; ++d) {
            for (int i=0;i<n;i++) for (int j=0;j<m;j++) {
                int t = endLen[d][i][j];
                if (!t) continue;
                ans = max(ans, t); // no-turn case

                int k = steps[d][i][j];
                int needNext = ((k+1)&1) ? 2 : 0; // expected value after (i,j)
                int nd = cw[d];                  // clockwise direction
                int x = i + dirs[nd].first, y = j + dirs[nd].second;
                if (inb(x,y)) {
                    int cont = (needNext==2) ? from2[nd][x][y] : from0[nd][x][y];
                    ans = max(ans, t + cont);
                }
            }
        }

        return ans;
    }
};
```

# Python
``` python []
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        dirs = [(-1, 1), (1, 1), (1, -1), (-1, -1)]  # 4 diagonals: ‚Üó, ‚Üò, ‚Üô, ‚Üñ
        cw = {0:1, 1:2, 2:3, 3:0}  # clockwise mapping

        # Iteration order for forward DP (so previous diagonal cell is ready first)
        def iter_order(dx, dy):
            is_ = range(n) if dx > 0 else range(n-1, -1, -1)
            js_ = range(m) if dy > 0 else range(m-1, -1, -1)
            for i in is_:
                for j in js_:
                    yield i, j

        # Iteration order for backward DP (so next diagonal cell is ready first)
        def iter_reverse(dx, dy):
            is_ = range(n-1, -1, -1) if dx > 0 else range(n)
            js_ = range(m-1, -1, -1) if dy > 0 else range(m)
            for i in is_:
                for j in js_:
                    yield i, j

        # DP tables
        endLen = [ [ [0]*m for _ in range(n) ] for _ in range(4) ]   # longest valid path ending at (i,j) in direction d
        stepsSinceOne = [ [ [-1]*m for _ in range(n) ] for _ in range(4) ] # steps since '1' (to know what comes next)
        from0 = [ [ [0]*m for _ in range(n) ] for _ in range(4) ]    # continuation if current cell is 0
        from2 = [ [ [0]*m for _ in range(n) ] for _ in range(4) ]    # continuation if current cell is 2

        # Build endLen and stepsSinceOne (straight runs starting at '1')
        for d, (dx, dy) in enumerate(dirs):
            for i, j in iter_order(dx, dy):
                v = grid[i][j]
                if v == 1:
                    endLen[d][i][j] = 1
                    stepsSinceOne[d][i][j] = 0
                else:
                    pi, pj = i - dx, j - dy
                    if 0 <= pi < n and 0 <= pj < m and endLen[d][pi][pj] > 0:
                        k = stepsSinceOne[d][pi][pj]
                        need = 2 if (k + 1) % 2 == 1 else 0  # expect 2 if odd, else 0
                        if v == need:
                            endLen[d][i][j] = endLen[d][pi][pj] + 1
                            stepsSinceOne[d][i][j] = k + 1

        # Build from0/from2 (longest alternating runs starting at this cell)
        for d, (dx, dy) in enumerate(dirs):
            for i, j in iter_reverse(dx, dy):
                v = grid[i][j]
                ni, nj = i + dx, j + dy
                if v == 0:
                    best = 1
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 2:
                        best = 1 + from2[d][ni][nj]
                    from0[d][i][j] = best
                elif v == 2:
                    best = 1
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 0:
                        best = 1 + from0[d][ni][nj]
                    from2[d][i][j] = best

        ans = 0

        # Combine no-turn and one-turn cases
        for d, (dx, dy) in enumerate(dirs):
            for i in range(n):
                for j in range(m):
                    t = endLen[d][i][j]
                    if t == 0: 
                        continue

                    # Case 1: straight path, no turn
                    ans = max(ans, t)

                    # Case 2: make one clockwise turn
                    k = stepsSinceOne[d][i][j]
                    need_next = 2 if (k + 1) % 2 == 1 else 0
                    nd = cw[d]  # clockwise direction
                    x, y = i + dirs[nd][0], j + dirs[nd][1]
                    if 0 <= x < n and 0 <= y < m:
                        cont = from2[nd][x][y] if need_next == 2 else from0[nd][x][y]
                        ans = max(ans, t + cont)

        return ans

        
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
