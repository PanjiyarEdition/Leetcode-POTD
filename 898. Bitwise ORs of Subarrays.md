# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr.

The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.

A subarray is a contiguous non-empty sequence of elements within an array.


# üìùCode ‚¨á:-


# Java
```java []
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int subarrayBitwiseORs(int[] arr) {
        // This set will store all unique OR values found across all subarrays.
        Set<Integer> resultOrs = new HashSet<>();
        
        // This set stores the distinct ORs of all subarrays ending at the previous position.
        Set<Integer> currentOrs = new HashSet<>();

        for (int x : arr) {
            // `nextOrs` will store the ORs of subarrays ending at the current element `x`.
            Set<Integer> nextOrs = new HashSet<>();
            
            // The subarray of just the element x gives an OR of x.
            nextOrs.add(x);

            // Compute new ORs by extending previous subarrays with the current element x.
            for (int y : currentOrs) {
                nextOrs.add(x | y);
            }

            // Add all newly found ORs to the main result set.
            resultOrs.addAll(nextOrs);
            
            // For the next iteration, the current results become the previous results.
            currentOrs = nextOrs;
        }

        return resultOrs.size();
    }
}

```

# C++
``` cpp []
#include <vector>
#include <unordered_set>

class Solution {
public:
    int subarrayBitwiseORs(std::vector<int>& arr) {
        // This set will store all unique OR values found across all subarrays.
        std::unordered_set<int> result_ors;
        
        // This set stores the distinct ORs of all subarrays ending at the previous position.
        std::unordered_set<int> current_ors;

        for (int x : arr) {
            // `next_ors` will store the ORs of subarrays ending at the current element `x`.
            std::unordered_set<int> next_ors;
            
            // The subarray of just the element x gives an OR of x.
            next_ors.insert(x);

            // Compute new ORs by extending previous subarrays with the current element x.
            for (int y : current_ors) {
                next_ors.insert(x | y);
            }

            // Add all newly found ORs to the main result set.
            result_ors.insert(next_ors.begin(), next_ors.end());
            
            // For the next iteration, the current results become the previous results.
            current_ors = next_ors;
        }

        return result_ors.size();
    }
};
```

# Python
``` python []
class Solution:
    def subarrayBitwiseORs(self, arr: list[int]) -> int:
        # This set will store all unique OR values found across all subarrays.
        result_ors = set()
        
        # This set stores the distinct ORs of all subarrays ending at the previous position.
        current_ors = set()

        # Iterate through each element of the array.
        for x in arr:
            # `next_ors` will store the ORs of subarrays ending at the current element `x`.
            # It's calculated by OR-ing x with all values in `current_ors`,
            # and adding x itself (for the subarray of length 1).
            next_ors = {x | y for y in current_ors}
            next_ors.add(x)
            
            # Add all newly found ORs for subarrays ending at x to the main result set.
            result_ors.update(next_ors)
            
            # For the next iteration, the current results become the previous results.
            current_ors = next_ors
            
        return len(result_ors) 
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
