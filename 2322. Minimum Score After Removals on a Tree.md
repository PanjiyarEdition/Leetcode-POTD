# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:

Get the XOR of all the values of the nodes for each of the three components respectively.
The difference between the largest XOR value and the smallest XOR value is the score of the pair.
For example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.
Return the minimum score of any possible pair of edge removals on the given tree.

# üìùCode ‚¨á:-


# Java
```java []
import java.util.*;

class Solution {
    private int[] subtreeXor;
    private Set<Integer>[] descendants;
    private List<Integer>[] graph;

    private void dfs(int node, int parent, int[] nums) {
        subtreeXor[node] = nums[node];
        descendants[node].add(node);

        for (int neighbor : graph[node]) {
            if (neighbor != parent) {
                dfs(neighbor, node, nums);
                subtreeXor[node] ^= subtreeXor[neighbor];
                descendants[node].addAll(descendants[neighbor]);
            }
        }
    }

    public int minimumScore(int[] nums, int[][] edges) {
        int n = nums.length;
        graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }

        subtreeXor = new int[n];
        descendants = new HashSet[n];
        for (int i = 0; i < n; i++) {
            descendants[i] = new HashSet<>();
        }

        dfs(0, -1, nums);

        int totalXor = subtreeXor[0];
        int minScore = Integer.MAX_VALUE;

        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int xorI = subtreeXor[i];
                int xorJ = subtreeXor[j];
                int val1, val2, val3;

                if (descendants[i].contains(j)) { // j is in i's subtree
                    val1 = xorJ;
                    val2 = xorI ^ xorJ;
                    val3 = totalXor ^ xorI;
                } else if (descendants[j].contains(i)) { // i is in j's subtree
                    val1 = xorI;
                    val2 = xorJ ^ xorI;
                    val3 = totalXor ^ xorJ;
                } else { // Independent subtrees
                    val1 = xorI;
                    val2 = xorJ;
                    val3 = totalXor ^ xorI ^ xorJ;
                }
                
                int maxVal = Math.max(val1, Math.max(val2, val3));
                int minVal = Math.min(val1, Math.min(val2, val3));
                minScore = Math.min(minScore, maxVal - minVal);
            }
        }

        return minScore;
    }
}

```

# C++
``` cpp []
#include <vector>
#include <numeric>
#include <algorithm>
#include <unordered_set>

class Solution {
public:
    std::vector<int> subtree_xor;
    std::vector<std::unordered_set<int>> descendants;
    std::vector<std::vector<int>> graph;

    void dfs(int node, int parent, const std::vector<int>& nums) {
        subtree_xor[node] = nums[node];
        descendants[node].insert(node);

        for (int neighbor : graph[node]) {
            if (neighbor != parent) {
                dfs(neighbor, node, nums);
                subtree_xor[node] ^= subtree_xor[neighbor];
                descendants[node].insert(descendants[neighbor].begin(), descendants[neighbor].end());
            }
        }
    }

    int minimumScore(std::vector<int>& nums, std::vector<std::vector<int>>& edges) {
        int n = nums.size();
        graph.assign(n, std::vector<int>());
        subtree_xor.assign(n, 0);
        descendants.assign(n, std::unordered_set<int>());

        for (const auto& edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        dfs(0, -1, nums);

        int total_xor = subtree_xor[0];
        int min_score = INT_MAX;

        for (int i = 1; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int xor_i = subtree_xor[i];
                int xor_j = subtree_xor[j];
                int val1, val2, val3;

                if (descendants[i].count(j)) { // j is in i's subtree
                    val1 = xor_j;
                    val2 = xor_i ^ xor_j;
                    val3 = total_xor ^ xor_i;
                } else if (descendants[j].count(i)) { // i is in j's subtree
                    val1 = xor_i;
                    val2 = xor_j ^ xor_i;
                    val3 = total_xor ^ xor_j;
                } else { // Independent subtrees
                    val1 = xor_i;
                    val2 = xor_j;
                    val3 = total_xor ^ xor_i ^ xor_j;
                }
                
                int score = std::max({val1, val2, val3}) - std::min({val1, val2, val3});
                min_score = std::min(min_score, score);
            }
        }

        return min_score;
    }
};
```

# Python
``` python []
class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        
        n = len(nums)
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u].append(v)
            graph[v].append(u)
            
        def fn(u): 
            score[u] = nums[u]
            child[u] = {u}
            for v in graph[u]: 
                if seen[v] == 0: 
                    seen[v] = 1
                    fn(v)
                    score[u] ^= score[v]
                    child[u] |= child[v]
        
        seen = [1] + [0]*(n-1)
        score = [0]*n
        child = [set() for _ in range(n)]
        fn(0)
        
        ans = inf 
        for u in range(1, n): 
            for v in range(u+1, n): 
                if u in child[v]: 
                    uu = score[u]
                    vv = score[v] ^ score[u]
                    xx = score[0] ^ score[v]
                elif v in child[u]: 
                    uu = score[u] ^ score[v]
                    vv = score[v]
                    xx = score[0] ^ score[u]
                else: 
                    uu = score[u]
                    vv = score[v]
                    xx = score[0] ^ score[u] ^ score[v]
                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))
        return ans      
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
