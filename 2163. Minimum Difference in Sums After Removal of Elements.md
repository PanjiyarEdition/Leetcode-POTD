# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given a 0-indexed integer array nums consisting of 3 * n elements.

You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:

The first n elements belonging to the first part and their sum is sumfirst.
The next n elements belonging to the second part and their sum is sumsecond.
The difference in sums of the two parts is denoted as sumfirst - sumsecond.

For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
Return the minimum difference possible between the sums of the two parts after the removal of n elements.


# üìùCode ‚¨á:-


# Java
```java []
import java.util.*;

class Solution {
    public long minimumDifference(int[] nums) {
        int n = nums.length, k = n / 3;
        long[] leftMins = new long[n];
        long[] rightMaxs = new long[n];

        PriorityQueue<Integer> maxLeft = new PriorityQueue<>(Collections.reverseOrder());
        long leftSum = 0;

        for (int i = 0; i < k; i++) {
            maxLeft.add(nums[i]);
            leftSum += nums[i];
        }
        leftMins[k - 1] = leftSum;

        for (int i = k; i < n - k; i++) {
            if (nums[i] < maxLeft.peek()) {
                leftSum += nums[i] - maxLeft.poll();
                maxLeft.add(nums[i]);
            }
            leftMins[i] = leftSum;
        }

        PriorityQueue<Integer> minRight = new PriorityQueue<>();
        long rightSum = 0;

        for (int i = n - 1; i >= n - k; i--) {
            minRight.add(nums[i]);
            rightSum += nums[i];
        }
        rightMaxs[n - k] = rightSum;

        for (int i = n - k - 1; i >= k - 1; i--) {
            if (nums[i] > minRight.peek()) {
                rightSum += nums[i] - minRight.poll();
                minRight.add(nums[i]);
            }
            rightMaxs[i] = rightSum;
        }

        long minDiff = Long.MAX_VALUE;
        for (int i = k - 1; i < n - k; i++) {
            minDiff = Math.min(minDiff, leftMins[i] - rightMaxs[i + 1]);
        }

        return minDiff;
    }
}

```

# C++
``` cpp []
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class Solution {
public:
    long long minimumDifference(vector<int>& nums) {
        int n = nums.size(), k = n / 3;
        vector<long long> leftMins(n, 0), rightMaxs(n, 0);

        priority_queue<int> maxLeft;
        long long leftSum = 0;

        for (int i = 0; i < k; ++i) {
            maxLeft.push(nums[i]);
            leftSum += nums[i];
        }
        leftMins[k - 1] = leftSum;

        for (int i = k; i < n - k; ++i) {
            if (nums[i] < maxLeft.top()) {
                leftSum += nums[i] - maxLeft.top();
                maxLeft.pop();
                maxLeft.push(nums[i]);
            }
            leftMins[i] = leftSum;
        }

        priority_queue<int, vector<int>, greater<int>> minRight;
        long long rightSum = 0;

        for (int i = n - 1; i >= n - k; --i) {
            minRight.push(nums[i]);
            rightSum += nums[i];
        }
        rightMaxs[n - k] = rightSum;

        for (int i = n - k - 1; i >= k - 1; --i) {
            if (nums[i] > minRight.top()) {
                rightSum += nums[i] - minRight.top();
                minRight.pop();
                minRight.push(nums[i]);
            }
            rightMaxs[i] = rightSum;
        }

        long long minDiff = LLONG_MAX;
        for (int i = k - 1; i < n - k; ++i) {
            minDiff = min(minDiff, leftMins[i] - rightMaxs[i + 1]);
        }

        return minDiff;
    }
};
```

# Python
``` python []
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        
        N = len(nums) // 3
        
        left = [-n for n in nums[:N]]
        heapify(left)
        sum_left = [sum(nums[:N])]
        
        for i in range(N, 2*N):
            curr = heappushpop(left, -nums[i])
            sum_left.append(sum_left[-1] + curr + nums[i])
            
        right = nums[2*N:]
        heapify(right)
        sum_right = [sum(right)]
        
        for i in reversed(range(N, 2*N)):
            curr = heappushpop(right, nums[i])
            sum_right.append(sum_right[-1] - curr + nums[i])
            
        return min(l - r for l, r in zip(sum_left, sum_right[::-1]))    
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
