# ğŸ“Description â¡:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.

Return the maximum number of events you can attend.


# ğŸ“Code â¬‡:-


# Java
```java []

class Solution {
    public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));
        
        int day = 0, index = 0 , n = events.length ,result = 0;      
        
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        while (!pq.isEmpty() || index < n) {
            if (pq.isEmpty()) {
                day = events[index][0];
            }
            while (index < n && events[index][0] <= day) {
                pq.offer(events[index][1]);
                index++;
            }
            pq.poll();
            result++; 
            day++;    

            while (!pq.isEmpty() && pq.peek() < day) {
                pq.poll();
            }
        }
        return result;
    }
}

```

# C++
``` cpp []
class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        // Sort events based on start day
        sort(events.begin(), events.end());
        
        priority_queue<int, vector<int>, greater<int>> minHeap;
        
        int day = 0, index = 0, n = events.size(), result = 0;
        
        while (!minHeap.empty() || index < n) {
            if (minHeap.empty()) {
                day = events[index][0];
            }
            while (index < n && events[index][0] <= day) {
                minHeap.push(events[index][1]);
                index++;
            }
            minHeap.pop();
            result++;
            day++;
            
            while (!minHeap.empty() && minHeap.top() < day) {
                minHeap.pop();
            }
        }
        return result;
    }
};
```

# Python
``` python []
import heapq
class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        # sort by: 1) start time, and if tie: 2) end time
        events = sorted(events, key= lambda x:(x[0], x[1]))
        current_day = 0
        heap = []
        count = 0
        i =0
        while i < len(events) or heap:
            #if heap is empty
            if not heap:
                current_day = events[i][0]
            while i < len(events) and events[i][0] <= current_day:
                heapq.heappush(heap, events[i][1])
                i+=1
            
            heapq.heappop(heap)
            count += 1
            current_day += 1

            while heap and heap[0] < current_day:
                heapq.heappop(heap)
        
        return count
```

---

>    **Coded** By $$Panjiyar EDITION ğŸ–‹  $$

               
