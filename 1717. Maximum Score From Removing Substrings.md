# üìçDescription ‚û°:-
<!-- Describe your first thoughts on how to solve this problem. -->
You are given a string s and two integers x and y. You can perform two types of operations any number of times.

Remove substring "ab" and gain x points.
For example, when removing "ab" from "cabxbae" it becomes "cxbae".
Remove substring "ba" and gain y points.
For example, when removing "ba" from "cabxbae" it becomes "cabxe".
Return the maximum points you can gain after applying the above operations on s.


# üìùCode ‚¨á:-


# Java
```java []
import java.util.*;

class Solution {
    private void clear(Stack<Pair> stack) {
        stack.clear();
    }

    public int maximumGain(String s, int x, int y) {
        int ans = 0;
        int n = s.length();

        if (y > x) {
            Stack<Pair> stack = new Stack<>();
            boolean[] vis = new boolean[n];

            // Prioritize "ba"
            for (int i = 0; i < n; i++) {
                if (!stack.isEmpty() && stack.peek().ch == 'b' && s.charAt(i) == 'a') {
                    vis[i] = true;
                    vis[stack.pop().idx] = true;
                    ans += y;
                } else {
                    stack.push(new Pair(s.charAt(i), i));
                }
            }

            clear(stack);

            // Process "ab"
            for (int i = 0; i < n; i++) {
                if (vis[i]) continue;
                if (!stack.isEmpty() && stack.peek().ch == 'a' && s.charAt(i) == 'b') {
                    stack.pop();
                    ans += x;
                } else {
                    stack.push(new Pair(s.charAt(i), i));
                }
            }

        } else {
            Stack<Pair> stack = new Stack<>();
            boolean[] vis = new boolean[n];

            // Prioritize "ab"
            for (int i = 0; i < n; i++) {
                if (!stack.isEmpty() && stack.peek().ch == 'a' && s.charAt(i) == 'b') {
                    vis[i] = true;
                    vis[stack.pop().idx] = true;
                    ans += x;
                } else {
                    stack.push(new Pair(s.charAt(i), i));
                }
            }

            clear(stack);

            // Process "ba"
            for (int i = 0; i < n; i++) {
                if (vis[i]) continue;
                if (!stack.isEmpty() && stack.peek().ch == 'b' && s.charAt(i) == 'a') {
                    stack.pop();
                    ans += y;
                } else {
                    stack.push(new Pair(s.charAt(i), i));
                }
            }
        }

        return ans;
    }

    static class Pair {
        char ch;
        int idx;

        Pair(char ch, int idx) {
            this.ch = ch;
            this.idx = idx;
        }
    }
}

```

# C++
``` cpp []
class Solution {
public:
    void clear(stack<pair<char, int>>& st){
        while(!st.empty()) st.pop();
    }

    int maximumGain(string s, int x, int y) {
        int ans = 0;
        int n = s.length();
        
        if (y > x) {
            stack<pair<char, int>> st;
            vector<int> vis(n);

            // Prioritize "ba" pairs
            for (int i = 0; i < s.length(); i++) {
                if (!st.empty() && st.top().first == 'b' && s[i] == 'a') {
                    vis[i] = 1;
                    vis[st.top().second] = 1;
                    st.pop();
                    ans += y;
                } else {
                    st.push({s[i], i});
                }
            }

            clear(st);

            // Process remaining "ab" pairs
            for (int i = 0; i < n; i++) {
                if (vis[i] == 1) continue;

                if (!st.empty() && st.top().first == 'a' && s[i] == 'b') {
                    st.pop();
                    ans += x;
                } else {
                    st.push({s[i], i});
                }
            }
        } else {
            stack<pair<char, int>> st;
            vector<int> vis(n);

            // Prioritize "ab" pairs
            for (int i = 0; i < s.length(); i++) {
                if (!st.empty() && st.top().first == 'a' && s[i] == 'b') {
                    vis[i] = 1;
                    vis[st.top().second] = 1;
                    st.pop();
                    ans += x;
                } else {
                    st.push({s[i], i});
                }
            }

            clear(st);

            // Process remaining "ba" pairs
            for (int i = 0; i < n; i++) {
                if (vis[i] == 1) continue;

                if (!st.empty() && st.top().first == 'b' && s[i] == 'a') {
                    st.pop();
                    ans += y;
                } else {
                    st.push({s[i], i});
                }
            }
        }

        return ans;
    }
};
```

# Python
``` python []
class Solution:
    def clear(self, st):
        st.clear()

    def maximumGain(self, s: str, x: int, y: int) -> int:
        ans = 0
        n = len(s)

        if y > x:
            st = []
            vis = [False] * n

            # Prioritize "ba"
            for i in range(n):
                if st and st[-1][0] == 'b' and s[i] == 'a':
                    vis[i] = True
                    vis[st[-1][1]] = True
                    st.pop()
                    ans += y
                else:
                    st.append((s[i], i))

            self.clear(st)

            # Process "ab"
            for i in range(n):
                if vis[i]:
                    continue
                if st and st[-1][0] == 'a' and s[i] == 'b':
                    st.pop()
                    ans += x
                else:
                    st.append((s[i], i))

        else:
            st = []
            vis = [False] * n

            # Prioritize "ab"
            for i in range(n):
                if st and st[-1][0] == 'a' and s[i] == 'b':
                    vis[i] = True
                    vis[st[-1][1]] = True
                    st.pop()
                    ans += x
                else:
                    st.append((s[i], i))

            self.clear(st)

            # Process "ba"
            for i in range(n):
                if vis[i]:
                    continue
                if st and st[-1][0] == 'b' and s[i] == 'a':
                    st.pop()
                    ans += y
                else:
                    st.append((s[i], i))

        return ans     
```

---

>    **Coded** By $$Panjiyar EDITION üñã  $$

               
